<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Performance Test - Pokemon BW/BW2 Initial Seed Search</title>
    <style>
        body { font-family: monospace; padding: 20px; background: #111; color: #fff; }
        .output { margin: 10px 0; padding: 10px; background: #222; border-radius: 4px; }
        .success { color: #0f0; }
        .error { color: #f00; }
        .warning { color: #ff0; }
        .info { color: #0af; }
        button { padding: 10px 20px; margin: 5px; background: #333; color: #fff; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background: #555; }
    </style>
</head>
<body>
    <h1>ğŸš€ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ - ãƒã‚±ãƒ¢ãƒ³BW/BW2åˆæœŸSeedæ¢ç´¢</h1>
    
    <div>
        <button onclick="runBasicTest()">åŸºæœ¬ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ</button>
        <button onclick="runScalabilityTest()">ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ</button>
        <button onclick="runBatchTest()">ãƒãƒƒãƒå‡¦ç†ãƒ†ã‚¹ãƒˆ</button>
        <button onclick="runMassiveTest()">å¤§è¦æ¨¡ã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆ (100ä¸‡è¨ˆç®—)</button>
        <button onclick="runProgressOverheadTest()">é€²æ—ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ãƒ†ã‚¹ãƒˆ</button>
        <button onclick="runComprehensiveTest()">åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆ</button>
        <button onclick="clearOutput()">ã‚¯ãƒªã‚¢</button>
    </div>
    
    <div id="output"></div>

    <script type="module">
        import { PerformanceAnalyzer, runPerformanceAnalysis } from '/src/lib/performance-analyzer.ts';
        
        let analyzer = null;
        
        // Initialize analyzer
        async function initAnalyzer() {
            if (!analyzer) {
                log('ğŸ”§ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚¢ãƒŠãƒ©ã‚¤ã‚¶ãƒ¼ã‚’åˆæœŸåŒ–ä¸­...', 'info');
                analyzer = new PerformanceAnalyzer();
                await analyzer.initialize();
                log('âœ… åˆæœŸåŒ–å®Œäº†', 'success');
            }
            return analyzer;
        }
        
        // Logging utility
        function log(message, type = 'info') {
            const output = document.getElementById('output');
            const div = document.createElement('div');
            div.className = `output ${type}`;
            div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            output.appendChild(div);
            output.scrollTop = output.scrollHeight;
            console.log(message);
        }
        
        window.runBasicTest = async function() {
            try {
                log('ğŸ“Š åŸºæœ¬ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆï¼ˆãƒªã‚¢ãƒ«ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ï¼‰ã‚’é–‹å§‹...', 'info');
                log('âš ï¸ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç”Ÿæˆãƒ»è¨ˆç®—ãƒ»ç›®æ¨™ç…§åˆã®å…¨ã¦ã‚’å«ã‚€å®Ÿéš›ã®æ¢ç´¢ã¨åŒã˜å‡¦ç†', 'warning');
                const analyzer = await initAnalyzer();
                const metrics = await analyzer.measureBasicPerformance(10000);
                
                log(`âœ… ãƒ†ã‚¹ãƒˆå®Œäº†`, 'success');
                log(`   è¨ˆç®—é€Ÿåº¦: ${metrics.calculationsPerSecond.toFixed(0)} calc/sec`, 'info');
                log(`   å®Ÿè¡Œæ™‚é–“: ${metrics.totalTime.toFixed(2)}ms`, 'info');
                log(`   ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡: ${(metrics.memoryUsage / 1024 / 1024).toFixed(2)}MB`, 'info');
                
                if (metrics.bottlenecks.length > 0) {
                    log(`âš ï¸ ãƒœãƒˆãƒ«ãƒãƒƒã‚¯æ¤œå‡º:`, 'warning');
                    metrics.bottlenecks.forEach(b => log(`   â€¢ ${b}`, 'warning'));
                }
                
                const recommendations = analyzer.generateRecommendations(metrics);
                if (recommendations.length > 0) {
                    log(`ğŸ’¡ æ¨å¥¨äº‹é …:`, 'info');
                    recommendations.forEach(r => log(`   ${r}`, 'info'));
                }
                
            } catch (error) {
                log(`âŒ ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`, 'error');
                console.error(error);
            }
        };
        
        window.runScalabilityTest = async function() {
            try {
                log('ğŸ“ˆ ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆã‚’é–‹å§‹...', 'info');
                const analyzer = await initAnalyzer();
                const results = await analyzer.testScalability(50000);
                
                log(`âœ… ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆå®Œäº†`, 'success');
                results.forEach(r => {
                    log(`Batch ${r.batchSize.toLocaleString()}: ${r.performance.calculationsPerSecond.toFixed(0)} calc/s, Stability: ${r.stabilityScore.toFixed(1)}`, 'info');
                });
                
            } catch (error) {
                log(`âŒ ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`, 'error');
                console.error(error);
            }
        };
        
        window.runBatchTest = async function() {
            try {
                log('ğŸ”„ ãƒãƒƒãƒå‡¦ç†ãƒ†ã‚¹ãƒˆï¼ˆãƒªã‚¢ãƒ«ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ï¼‰ã‚’é–‹å§‹...', 'info');
                log('âš ï¸ å®Ÿéš›ã®æ¢ç´¢ã¨åŒã˜å‡¦ç†ï¼šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç”Ÿæˆâ†’è¨ˆç®—â†’ç›®æ¨™ç…§åˆ', 'warning');
                const analyzer = await initAnalyzer();
                
                const testConditions = {
                    romVersion: 'B',
                    romRegion: 'JPN',
                    hardware: 'DS',
                    macAddress: [0x00, 0x16, 0x56, 0xAE, 0xBB, 0xCC],
                    keyInput: 0x02000000,
                    timer0Range: { min: 4320, max: 4320, useAutoRange: false },
                    vcountRange: { min: 128, max: 128, useAutoRange: false },
                    dateRange: {
                        startYear: 2023, startMonth: 12, startDay: 31,
                        startHour: 23, startMinute: 59, startSecond: 59,
                        endYear: 2023, endMonth: 12, endDay: 31,
                        endHour: 23, endMinute: 59, endSecond: 59
                    }
                };
                
                const batchSizes = [100, 500, 1000, 2000, 5000, 10000];
                
                for (const batchSize of batchSizes) {
                    log(`Testing batch size: ${batchSize.toLocaleString()}...`, 'info');
                    const metrics = await analyzer.measureBatchPerformance(testConditions, batchSize);
                    log(`   Speed: ${metrics.calculationsPerSecond.toFixed(0)} calc/sec`, 'info');
                    log(`   Time: ${metrics.calculationTime.toFixed(2)}ms`, 'info');
                    
                    if (metrics.bottlenecks.length > 0) {
                        log(`   Bottlenecks: ${metrics.bottlenecks.join(', ')}`, 'warning');
                    }
                }
                
                log(`âœ… ãƒãƒƒãƒå‡¦ç†ãƒ†ã‚¹ãƒˆå®Œäº†`, 'success');
                
            } catch (error) {
                log(`âŒ ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`, 'error');
                console.error(error);
            }
        };
        
        window.runMassiveTest = async function() {
            try {
                log('ğŸ”¥ å¤§è¦æ¨¡ã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆ (100ä¸‡è¨ˆç®—ãƒ»ãƒªã‚¢ãƒ«ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼) ã‚’é–‹å§‹...', 'info');
                log('âš ï¸ æ³¨æ„: ã“ã®ãƒ†ã‚¹ãƒˆã¯å®Ÿéš›ã®æ¢ç´¢ã¨åŒã˜å‡¦ç†ã§æ•°åˆ†ã‹ã‹ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™', 'warning');
                log('ğŸ“Š ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç”Ÿæˆãƒ»è¨ˆç®—ãƒ»ç›®æ¨™ç…§åˆã‚’å…¨ã¦å«ã‚€å®Œå…¨ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼', 'info');
                const analyzer = await initAnalyzer();
                
                const metrics = await analyzer.measureMassiveBatchPerformance(1000000);
                
                log(`âœ… å¤§è¦æ¨¡ã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆå®Œäº†`, 'success');
                log(`   è¨ˆç®—æ•°: 1,000,000`, 'info');
                log(`   é€Ÿåº¦: ${metrics.calculationsPerSecond.toFixed(0)} calc/sec`, 'info');
                log(`   å®Ÿè¡Œæ™‚é–“: ${(metrics.totalTime / 1000).toFixed(2)}ç§’`, 'info');
                log(`   ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡: ${(metrics.memoryUsage / 1024 / 1024).toFixed(2)}MB`, 'info');
                
                // Calculate time for 1 million calculations
                const timeFor1Million = (1000000 / metrics.calculationsPerSecond) / 60;
                const target = 10; // 10 minutes
                
                if (timeFor1Million <= target) {
                    log(`ğŸŸ¢ ç›®æ¨™é”æˆ! 100ä¸‡è¨ˆç®—: ${timeFor1Million.toFixed(1)}åˆ† (ç›®æ¨™: ${target}åˆ†ä»¥å†…)`, 'success');
                } else {
                    log(`ğŸ”´ ç›®æ¨™æœªé”æˆ! 100ä¸‡è¨ˆç®—: ${timeFor1Million.toFixed(1)}åˆ† (ç›®æ¨™: ${target}åˆ†ä»¥å†…)`, 'error');
                }
                
                if (metrics.bottlenecks.length > 0) {
                    log(`âš ï¸ å•é¡Œç‚¹:`, 'warning');
                    metrics.bottlenecks.forEach(b => log(`   â€¢ ${b}`, 'warning'));
                }
                
                const recommendations = analyzer.generateRecommendations(metrics);
                if (recommendations.length > 0) {
                    log(`ğŸ’¡ æ¨å¥¨äº‹é …:`, 'info');
                    recommendations.forEach(r => log(`   ${r}`, 'info'));
                }
                
            } catch (error) {
                log(`âŒ ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`, 'error');
                console.error(error);
            }
        };
        
        window.runComprehensiveTest = async function() {
            try {
                log('ğŸ¯ åŒ…æ‹¬çš„ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã‚’é–‹å§‹...', 'info');
                await runPerformanceAnalysis();
                log(`âœ… åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆå®Œäº†`, 'success');
                
            } catch (error) {
                log(`âŒ ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`, 'error');
                console.error(error);
            }
        };

        window.runProgressOverheadTest = async function() {
            try {
                log('ğŸ“Š é€²æ—æ›´æ–°ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ãƒ†ã‚¹ãƒˆã‚’é–‹å§‹...', 'info');
                log('âš ï¸ å®Ÿéš›ã®E2Eæ¤œç´¢ã§ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ä½ä¸‹åŸå› ã‚’èª¿æŸ»', 'warning');
                const analyzer = await initAnalyzer();
                
                // Test 1: Pure computation (no progress updates)
                log('ğŸ”§ ãƒ†ã‚¹ãƒˆ1: ç´”ç²‹ãªè¨ˆç®—å‡¦ç†ï¼ˆé€²æ—æ›´æ–°ãªã—ï¼‰', 'info');
                const pureMetrics = await analyzer.measureBasicPerformance(50000);
                log(`   ç´”ç²‹è¨ˆç®—é€Ÿåº¦: ${pureMetrics.calculationsPerSecond.toFixed(0)} calc/sec`, 'info');
                
                // Test 2: With simulated progress updates
                log('ğŸ”§ ãƒ†ã‚¹ãƒˆ2: é€²æ—æ›´æ–°ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ä»˜ã', 'info');
                const progressMetrics = await analyzer.measureWithProgressOverhead(50000, 1000); // 1000è¨ˆç®—æ¯ã«æ›´æ–°
                log(`   é€²æ—æ›´æ–°ä»˜ãé€Ÿåº¦: ${progressMetrics.calculationsPerSecond.toFixed(0)} calc/sec`, 'info');
                
                // Test 3: With frequent progress updates (like E2E)
                log('ğŸ”§ ãƒ†ã‚¹ãƒˆ3: é »ç¹ãªé€²æ—æ›´æ–°ï¼ˆE2Eç›¸å½“ï¼‰', 'info');
                const frequentMetrics = await analyzer.measureWithProgressOverhead(50000, 100); // 100è¨ˆç®—æ¯ã«æ›´æ–°
                log(`   é »ç¹æ›´æ–°ä»˜ãé€Ÿåº¦: ${frequentMetrics.calculationsPerSecond.toFixed(0)} calc/sec`, 'info');
                
                // Calculate overhead
                const progressOverhead = ((pureMetrics.calculationsPerSecond - progressMetrics.calculationsPerSecond) / pureMetrics.calculationsPerSecond * 100);
                const frequentOverhead = ((pureMetrics.calculationsPerSecond - frequentMetrics.calculationsPerSecond) / pureMetrics.calculationsPerSecond * 100);
                
                log('ğŸ“ˆ ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰åˆ†æ:', 'info');
                log(`   é€²æ—æ›´æ–°ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰: ${progressOverhead.toFixed(1)}%`, 'warning');
                log(`   é »ç¹æ›´æ–°ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰: ${frequentOverhead.toFixed(1)}%`, 'warning');
                
                if (frequentOverhead > 30) {
                    log('âš ï¸ é‡å¤§: é »ç¹ãªé€²æ—æ›´æ–°ãŒ30%ä»¥ä¸Šã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ä½ä¸‹ã‚’å¼•ãèµ·ã“ã—ã¦ã„ã¾ã™', 'error');
                    log('ğŸ’¡ æ¨å¥¨: ãƒãƒƒãƒã‚µã‚¤ã‚ºã‚’å¢—ã‚„ã™ã‹ã€é€²æ—æ›´æ–°é »åº¦ã‚’ä¸‹ã’ã¦ãã ã•ã„', 'info');
                }
                
                log('âœ… é€²æ—ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                
            } catch (error) {
                log(`âŒ ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`, 'error');
                console.error(error);
            }
        };
        
        window.clearOutput = function() {
            document.getElementById('output').innerHTML = '';
        };
        
        // Auto-initialize on page load
        document.addEventListener('DOMContentLoaded', async () => {
            log('ğŸš€ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆãƒšãƒ¼ã‚¸ãŒèª­ã¿è¾¼ã¾ã‚Œã¾ã—ãŸ', 'success');
            log('ä¸Šè¨˜ã®ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„', 'info');
        });
    </script>
</body>
</html>
