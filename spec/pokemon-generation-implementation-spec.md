# ãƒã‚±ãƒ¢ãƒ³ç”Ÿæˆæ©Ÿèƒ½ å®Ÿè£…ä»•æ§˜æ›¸

> âš ï¸ **é‡è¦ãªãŠçŸ¥ã‚‰ã›**  
> ã“ã®å®Ÿè£…ä»•æ§˜æ›¸ã¯åˆ†å‰²ã•ã‚Œã¾ã—ãŸã€‚æ–°ã—ã„æ§‹æˆã«ã¤ã„ã¦ã¯ä»¥ä¸‹ã‚’ã”ç¢ºèªãã ã•ã„ï¼š

## ğŸ“ æ–°ã—ã„ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ§‹æˆ

å®Ÿè£…ä»•æ§˜æ›¸ã¯ä¿å®ˆæ€§å‘ä¸Šã®ãŸã‚ã€ä»¥ä¸‹ã®4ã¤ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«åˆ†å‰²ã•ã‚Œã¾ã—ãŸï¼š

### 1. **[implementation/01-architecture.md](./implementation/01-architecture.md)** - ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ
- å…¨ä½“æ§‹æˆè¨­è¨ˆ
- WASM-TypeScript ãƒ‡ãƒ¼ã‚¿ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹  
- ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«è¨­è¨ˆã¨è²¬ä»»åˆ†é›¢
- ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼è¨­è¨ˆ

### 2. **[implementation/02-algorithms.md](./implementation/02-algorithms.md)** - æ ¸å¿ƒã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Ÿè£…
- æ€§æ ¼å€¤ä¹±æ•°åˆ—ã‚¨ãƒ³ã‚¸ãƒ³ï¼ˆWASMå®Ÿè£…ï¼‰
- é­é‡è¨ˆç®—ã‚¨ãƒ³ã‚¸ãƒ³ï¼ˆWASMå®Ÿè£…ï¼‰ 
- çµ±åˆPokemon Generatorï¼ˆWASMå®Ÿè£…ï¼‰
- æ€§æ ¼å€¤ãƒ»è‰²é•ã„åˆ¤å®šã®è©³ç´°å®Ÿè£…

### 3. **[implementation/03-data-management.md](./implementation/03-data-management.md)** - ãƒ‡ãƒ¼ã‚¿ç®¡ç†å®Ÿè£…  
- Generation Data Managerï¼ˆTypeScriptå´ï¼‰
- ç¨®æ—ãƒ‡ãƒ¼ã‚¿ãƒ»é­é‡ãƒ†ãƒ¼ãƒ–ãƒ«ãƒ»ç‰¹æ€§ãƒ‡ãƒ¼ã‚¿ç®¡ç†
- ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯

### 4. **[implementation/04-implementation-phases.md](./implementation/04-implementation-phases.md)** - å®Ÿè£…ãƒ•ã‚§ãƒ¼ã‚º
- Phase 1: WASM Core Engineï¼ˆ3é€±é–“ï¼‰
- Phase 2: TypeScript Integrationï¼ˆ2é€±é–“ï¼‰ 
- Phase 3: UI Componentsï¼ˆ2é€±é–“ï¼‰
- Phase 4: WebWorker & Performanceï¼ˆ1é€±é–“ï¼‰
- Phase 5: Polish & Validationï¼ˆ1é€±é–“ï¼‰

## ğŸ¯ æ¨å¥¨åˆ©ç”¨æ–¹æ³•

1. **æ–°è¦å®Ÿè£…æ™‚**: `implementation/README.md` â†’ å„åˆ†å‰²ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆå‚ç…§
2. **ä¿å®ˆãƒ»æ›´æ–°æ™‚**: è©²å½“ã™ã‚‹åˆ†å‰²ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’ç›´æ¥å‚ç…§
3. **ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ç†è§£**: `01-architecture.md` ã‹ã‚‰é–‹å§‹
4. **ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Ÿè£…**: `02-algorithms.md` ã‚’å‚ç…§

---

## åˆ†å‰²å‰ã®çµ±åˆå®Ÿè£…ä»•æ§˜æ›¸ï¼ˆãƒ¬ã‚¬ã‚·ãƒ¼ï¼‰

ä»¥ä¸‹ã¯åˆ†å‰²å‰ã®å®Ÿè£…ä»•æ§˜æ›¸ã§ã™ã€‚æ–°ã—ã„åˆ†å‰²ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¸ã®ç§»è¡Œã‚’æ¨å¥¨ã—ã¾ã™ãŒã€å‚è€ƒã¨ã—ã¦ä¿æŒã—ã¦ã„ã¾ã™ã€‚

---

## 2. ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆï¼ˆãƒ¬ã‚¬ã‚·ãƒ¼ï¼‰

### 2.1 å…¨ä½“æ§‹æˆï¼ˆä¿®æ­£ç‰ˆï¼‰

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   UI Layer      â”‚    â”‚  Service Layer  â”‚    â”‚   Data Layer    â”‚
â”‚  (TypeScript)   â”‚    â”‚  (TypeScript)   â”‚    â”‚  (TypeScript)   â”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ - React         â”‚ â†â†’ â”‚ - Result Parser â”‚ â†â†’ â”‚ - Species Data  â”‚
â”‚   Components    â”‚    â”‚ - Data Manager  â”‚    â”‚ - Encounter     â”‚
â”‚ - Form Handling â”‚    â”‚ - UI Controller â”‚    â”‚   Tables        â”‚
â”‚ - State Mgmt    â”‚    â”‚ - Export Logic  â”‚    â”‚ - Static Data   â”‚
â”‚   (Zustand)     â”‚    â”‚                 â”‚    â”‚   (JSON)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                       â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  WASM Layer     â”‚
                    â”‚     (Rust)      â”‚
                    â”‚                 â”‚
                    â”‚ - 64bit LCG     â”‚
                    â”‚ - Pokemon Gen   â”‚
                    â”‚ - Encounter     â”‚
                    â”‚   Calculation   â”‚
                    â”‚ - Raw Data Gen  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**é‡è¦ãªè¨­è¨ˆå¤‰æ›´**:
- **è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯**: å…¨ã¦WASMå´ã§å®Ÿè£…
- **TypeScriptå´**: çµæœã®ãƒ‘ãƒ¼ã‚¹ãƒ»UIè¡¨ç¤ºã®ã¿
- **ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè£…**: æä¾›ã—ãªã„

### 2.2 WASM-TypeScript ãƒ‡ãƒ¼ã‚¿ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

#### 2.2.1 WASMå´å‡ºåŠ›ãƒ‡ãƒ¼ã‚¿æ§‹é€ 

```rust
// wasm-pkg/src/pokemon_data.rs
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub struct RawPokemonData {
    // åŸºæœ¬ãƒ‡ãƒ¼ã‚¿
    personality_value: u32,      // æ€§æ ¼å€¤ï¼ˆPIDï¼‰
    encounter_slot_value: u32,   // é­é‡ã‚¹ãƒ­ãƒƒãƒˆå€¤
    nature_id: u32,             // æ€§æ ¼IDï¼ˆ0-24ï¼‰
    sync_applied: bool,         // ã‚·ãƒ³ã‚¯ãƒ­é©ç”¨ãƒ•ãƒ©ã‚°
    advances: u32,              // æ¶ˆè²»æ•°
    
    // è¿½åŠ æƒ…å ±
    level: u8,                  // ãƒ¬ãƒ™ãƒ«
    shiny_flag: bool,           // è‰²é•ã„ãƒ•ãƒ©ã‚°
    ability_slot: u8,           // ç‰¹æ€§ã‚¹ãƒ­ãƒƒãƒˆï¼ˆ1 or 2ï¼‰
    gender_value: u8,           // æ€§åˆ¥åˆ¤å®šå€¤
    
    // ãƒ‡ãƒãƒƒã‚°æƒ…å ±
    rng_seed_used: u64,         // ä½¿ç”¨ã•ã‚ŒãŸseed
    encounter_type: u32,        // é­é‡ã‚¿ã‚¤ãƒ—
}

#[wasm_bindgen]
impl RawPokemonData {
    // Getter methods for JavaScript access
    #[wasm_bindgen(getter)]
    pub fn personality_value(&self) -> u32 { self.personality_value }
    
    #[wasm_bindgen(getter)]
    pub fn encounter_slot_value(&self) -> u32 { self.encounter_slot_value }
    
    #[wasm_bindgen(getter)]
    pub fn nature_id(&self) -> u32 { self.nature_id }
    
    #[wasm_bindgen(getter)]
    pub fn sync_applied(&self) -> bool { self.sync_applied }
    
    #[wasm_bindgen(getter)]
    pub fn advances(&self) -> u32 { self.advances }
    
    #[wasm_bindgen(getter)]
    pub fn level(&self) -> u8 { self.level }
    
    #[wasm_bindgen(getter)]
    pub fn shiny_flag(&self) -> bool { self.shiny_flag }
    
    #[wasm_bindgen(getter)]
    pub fn ability_slot(&self) -> u8 { self.ability_slot }
    
    #[wasm_bindgen(getter)]
    pub fn gender_value(&self) -> u8 { self.gender_value }
    
    #[wasm_bindgen(getter)]
    pub fn rng_seed_used(&self) -> u64 { self.rng_seed_used }
    
    #[wasm_bindgen(getter)]
    pub fn encounter_type(&self) -> u32 { self.encounter_type }
}
```

#### 2.2.2 TypeScriptå´ãƒ‡ãƒ¼ã‚¿ãƒ‘ãƒ¼ã‚µãƒ¼

```typescript
// src/lib/generation/result-parser.ts
interface GeneratedPokemon {
  // åŸºæœ¬æƒ…å ±
  species: string;
  level: number;
  nature: PokemonNature;
  ability: AbilityData;
  gender: Gender;
  isShiny: boolean;
  
  // è©³ç´°æƒ…å ±
  personalityValue: number;
  encounterSlot: number;
  advances: number;
  
  // ãƒ¡ã‚¿æƒ…å ±
  synchronizeApplied: boolean;
  frame: number;
  rngSeedUsed: bigint;
}

class PokemonResultParser {
  constructor(
    private dataManager: GenerationDataManager,
    private gameVersion: GameVersion
  ) {}
  
  // WASMå‡ºåŠ›ã‚’TypeScriptå‹ã«å¤‰æ›
  parseRawData(rawData: RawPokemonData, encounterParams: EncounterParams): GeneratedPokemon {
    return {
      // å‡ºç¾ãƒã‚±ãƒ¢ãƒ³æ±ºå®šï¼ˆé­é‡ã‚¹ãƒ­ãƒƒãƒˆ â†’ ã‚¨ãƒ³ã‚«ã‚¦ãƒ³ãƒˆãƒ†ãƒ¼ãƒ–ãƒ«å‚ç…§ï¼‰
      species: this.determineSpecies(rawData.encounter_slot_value, encounterParams),
      
      // ãƒ¬ãƒ™ãƒ«ã¯WASMå´ã§è¨ˆç®—æ¸ˆã¿
      level: rawData.level,
      
      // æ€§æ ¼ã¯æ€§æ ¼IDã‹ã‚‰å¤‰æ›
      nature: this.getNatureFromId(rawData.nature_id),
      
      // ç‰¹æ€§æ±ºå®šï¼ˆæ€§æ ¼å€¤ã®16bitç›®ã§åˆ¤å®šï¼‰
      ability: this.determineAbility(rawData.personality_value, rawData.encounter_slot_value, encounterParams),
      
      // æ€§åˆ¥æ±ºå®šï¼ˆæ€§æ ¼å€¤ä¸‹ä½8bit vs ç¨®æ—é–¾å€¤ï¼‰
      gender: this.determineGender(rawData.personality_value, rawData.encounter_slot_value, encounterParams),
      
      // è‰²é•ã„ã¯WASMå´ã§åˆ¤å®šæ¸ˆã¿
      isShiny: rawData.shiny_flag,
      
      // è©³ç´°æƒ…å ±
      personalityValue: rawData.personality_value,
      encounterSlot: rawData.encounter_slot_value,
      advances: rawData.advances,
      
      // ãƒ¡ã‚¿æƒ…å ±
      synchronizeApplied: rawData.sync_applied,
      frame: rawData.advances,
      rngSeedUsed: BigInt(rawData.rng_seed_used),
    };
  }
  
  private determineSpecies(slotValue: number, encounterParams: EncounterParams): string {
    const encounterTable = this.dataManager.getEncounterTable(encounterParams.location);
    if (!encounterTable) throw new Error(`Unknown location: ${encounterParams.location}`);
    
    // é­é‡ã‚¹ãƒ­ãƒƒãƒˆå€¤ã‚’ãƒ†ãƒ¼ãƒ–ãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«å¤‰æ›
    const calculator = new EncounterCalculator(this.gameVersion);
    const tableIndex = calculator.slot_to_table_index(slotValue, encounterParams.type);
    
    return encounterTable.slots[tableIndex]?.pokemon || 'Unknown';
  }
  
  private determineAbility(pid: number, slotValue: number, encounterParams: EncounterParams): AbilityData {
    const species = this.determineSpecies(slotValue, encounterParams);
    const speciesData = this.dataManager.getSpecies(species);
    if (!speciesData) throw new Error(`Unknown species: ${species}`);
    
    // æ€§æ ¼å€¤ã®16bitç›®ã§ç‰¹æ€§åˆ¤å®š
    const abilitySlot = (pid >> 16) & 1;
    const abilityName = abilitySlot === 0 ? speciesData.abilities.ability1 : speciesData.abilities.ability2;
    
    return this.dataManager.getAbility(abilityName);
  }
  
  private determineGender(pid: number, slotValue: number, encounterParams: EncounterParams): Gender {
    const species = this.determineSpecies(slotValue, encounterParams);
    const speciesData = this.dataManager.getSpecies(species);
    if (!speciesData) throw new Error(`Unknown species: ${species}`);
    
    // æ€§åˆ¥æ¯”ç‡ãŒå›ºå®šã®å ´åˆ
    if (speciesData.genderRatio === 'genderless') return 'genderless';
    if (speciesData.genderRatio === 'male-only') return 'male';
    if (speciesData.genderRatio === 'female-only') return 'female';
    
    // æ€§æ ¼å€¤ä¸‹ä½8bit vs ç¨®æ—é–¾å€¤ã§åˆ¤å®š
    const genderValue = pid & 0xFF;
    const threshold = this.getGenderThreshold(speciesData.genderRatio);
    
    return genderValue < threshold ? 'female' : 'male';
  }
  
  private getNatureFromId(natureId: number): PokemonNature {
    const natureList = [
      'Hardy', 'Lonely', 'Brave', 'Adamant', 'Naughty',
      'Bold', 'Docile', 'Relaxed', 'Impish', 'Lax',
      'Timid', 'Hasty', 'Serious', 'Jolly', 'Naive',
      'Modest', 'Mild', 'Quiet', 'Bashful', 'Rash',
      'Calm', 'Gentle', 'Sassy', 'Careful', 'Quirky'
    ];
    
    return natureList[natureId] as PokemonNature;
  }
  
  private getGenderThreshold(genderRatio: string): number {
    const ratioMap: Record<string, number> = {
      '87.5:12.5': 31,   // 87.5% male (starterç­‰)
      '75:25': 63,       // 75% male
      '50:50': 127,      // 50% male
      '25:75': 191,      // 25% male
      '12.5:87.5': 225,  // 12.5% male
    };
    
    return ratioMap[genderRatio] || 127;
  }
}
```

### 2.3 ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«è¨­è¨ˆï¼ˆä¿®æ­£ç‰ˆï¼‰

```
src/
â”œâ”€â”€ components/
â”‚   â””â”€â”€ generation/
â”‚       â”œâ”€â”€ GenerationTab.tsx           # ãƒ¡ã‚¤ãƒ³ã‚¿ãƒ–ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”‚       â”œâ”€â”€ input/
â”‚       â”‚   â”œâ”€â”€ BasicParamsCard.tsx     # åŸºæœ¬ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å…¥åŠ›
â”‚       â”‚   â”œâ”€â”€ EncounterSettingsCard.tsx # é­é‡è¨­å®š
â”‚       â”‚   â”œâ”€â”€ WildEncounterForm.tsx   # é‡ç”Ÿé­é‡ãƒ•ã‚©ãƒ¼ãƒ 
â”‚       â”‚   â”œâ”€â”€ StaticEncounterForm.tsx # å›ºå®šã‚·ãƒ³ãƒœãƒ«ãƒ•ã‚©ãƒ¼ãƒ 
â”‚       â”‚   â”œâ”€â”€ RoamingEncounterForm.tsx # å¾˜å¾Šãƒã‚±ãƒ¢ãƒ³ãƒ•ã‚©ãƒ¼ãƒ 
â”‚       â”‚   â””â”€â”€ GenerationRangeCard.tsx # ç”Ÿæˆç¯„å›²è¨­å®š
â”‚       â”œâ”€â”€ results/
â”‚       â”‚   â”œâ”€â”€ ResultsTable.tsx        # çµæœãƒ†ãƒ¼ãƒ–ãƒ«
â”‚       â”‚   â”œâ”€â”€ ResultsCard.tsx         # ã‚«ãƒ¼ãƒ‰è¡¨ç¤º
â”‚       â”‚   â”œâ”€â”€ PokemonDetails.tsx      # è©³ç´°è¡¨ç¤º
â”‚       â”‚   â”œâ”€â”€ StatisticsPanel.tsx     # çµ±è¨ˆãƒ‘ãƒãƒ«
â”‚       â”‚   â””â”€â”€ FilterControls.tsx      # ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼åˆ¶å¾¡
â”‚       â””â”€â”€ controls/
â”‚           â”œâ”€â”€ GenerationControls.tsx  # ç”Ÿæˆåˆ¶å¾¡ãƒœã‚¿ãƒ³
â”‚           â”œâ”€â”€ ProgressDisplay.tsx     # é€²æ—è¡¨ç¤º
â”‚           â””â”€â”€ ExportControls.tsx      # ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆåˆ¶å¾¡
â”œâ”€â”€ lib/
â”‚   â””â”€â”€ generation/
â”‚       â”œâ”€â”€ pokemon-generator-service.ts # WASMãƒ©ãƒƒãƒ‘ãƒ¼ã‚µãƒ¼ãƒ“ã‚¹
â”‚       â”œâ”€â”€ result-parser.ts            # WASMçµæœãƒ‘ãƒ¼ã‚µãƒ¼
â”‚       â”œâ”€â”€ data-manager.ts             # é™çš„ãƒ‡ãƒ¼ã‚¿ç®¡ç†
â”‚       â”œâ”€â”€ validation.ts               # å…¥åŠ›æ¤œè¨¼
â”‚       â””â”€â”€ export-manager.ts           # ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå‡¦ç†
â”œâ”€â”€ data/
â”‚   â””â”€â”€ generation/
â”‚       â”œâ”€â”€ species/                    # ç¨®æ—ãƒ‡ãƒ¼ã‚¿
â”‚       â”œâ”€â”€ encounters/                 # é­é‡ãƒ‡ãƒ¼ã‚¿
â”‚       â”œâ”€â”€ game-data/                 # ã‚²ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿
â”‚       â””â”€â”€ constants/                 # å®šæ•°ãƒ‡ãƒ¼ã‚¿
â”œâ”€â”€ types/
â”‚   â””â”€â”€ generation.ts                  # å‹å®šç¾©
â”œâ”€â”€ store/
â”‚   â””â”€â”€ generation-store.ts            # çŠ¶æ…‹ç®¡ç†
â””â”€â”€ workers/
    â””â”€â”€ pokemon-generation-worker.ts    # ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å‡¦ç†

wasm-pkg/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs                         # WASMã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
â”‚   â”œâ”€â”€ personality_rng.rs             # æ€§æ ¼å€¤ä¹±æ•°åˆ—ã‚¨ãƒ³ã‚¸ãƒ³
â”‚   â”œâ”€â”€ encounter_calculator.rs        # é­é‡ã‚¹ãƒ­ãƒƒãƒˆè¨ˆç®—
â”‚   â”œâ”€â”€ pokemon_generator.rs           # ãƒ¡ã‚¤ãƒ³ç”Ÿæˆã‚¨ãƒ³ã‚¸ãƒ³
â”‚   â”œâ”€â”€ pokemon_data.rs                # ãƒ‡ãƒ¼ã‚¿æ§‹é€ å®šç¾©
â”‚   â””â”€â”€ utils.rs                       # ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
â””â”€â”€ Cargo.toml                         # Rustè¨­å®š
```

### 2.4 è²¬ä»»åˆ†é›¢ã®åŸå‰‡

#### WASMå´ã®è²¬ä»»
- **64bitç·šå½¢åˆåŒæ³•ã«ã‚ˆã‚‹ä¹±æ•°ç”Ÿæˆ**
- **BW/BW2åˆ¥ã®é­é‡ã‚¹ãƒ­ãƒƒãƒˆè¨ˆç®—**
- **æ€§æ ¼å€¤ãƒ»æ€§æ ¼ãƒ»ãƒ¬ãƒ™ãƒ«æ±ºå®š**
- **è‰²é•ã„åˆ¤å®š**
- **é«˜é€Ÿãƒãƒƒãƒå‡¦ç†**

#### TypeScriptå´ã®è²¬ä»»
- **WASMçµæœã®ãƒ‘ãƒ¼ã‚¹ãƒ»å¤‰æ›**
- **ã‚¨ãƒ³ã‚«ã‚¦ãƒ³ãƒˆãƒ†ãƒ¼ãƒ–ãƒ«ã¨ã®ç…§åˆ**
- **ç¨®æ—ãƒ‡ãƒ¼ã‚¿ã¨ã®çµ±åˆ**
- **UIè¡¨ç¤ºãƒ»çŠ¶æ…‹ç®¡ç†**
- **ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒ»ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°**

#### å¢ƒç•Œã®æ˜ç¢ºåŒ–
- **WASMã¯RawPokemonDataã®ã¿è¿”å´**
- **TypeScriptã¯è¡¨ç¤ºç”¨ãƒ‡ãƒ¼ã‚¿ã«å¤‰æ›**
- **è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯ã®é‡è¤‡ã‚’å®Œå…¨ã«æ’é™¤**

## 3. ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼è¨­è¨ˆ

### 3.1 çŠ¶æ…‹ç®¡ç†ï¼ˆZustandï¼‰

```typescript
interface GenerationStore {
  // å…¥åŠ›çŠ¶æ…‹
  input: {
    basicParams: BasicParams;
    encounterSettings: EncounterSettings;
    generationRange: GenerationRange;
  };
  
  // è¨ˆç®—çŠ¶æ…‹
  generation: {
    isRunning: boolean;
    isPaused: boolean;
    progress: GenerationProgress;
    results: GeneratedPokemon[];
    statistics: GenerationStatistics;
  };
  
  // UIçŠ¶æ…‹
  ui: {
    activeView: 'table' | 'cards';
    filters: FilterSettings;
    sorting: SortSettings;
    selectedPokemon?: GeneratedPokemon;
    showDetails: boolean;
  };
  
  // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
  actions: {
    updateInput: (section: string, data: any) => void;
    startGeneration: () => Promise<void>;
    pauseGeneration: () => void;
    stopGeneration: () => void;
    applyFilters: (filters: FilterSettings) => void;
    exportResults: (format: ExportFormat) => void;
  };
}
```

### 3.2 WebWorkeré€šä¿¡

```typescript
// ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ â†’ Worker
interface GenerationWorkerRequest {
  type: 'START' | 'PAUSE' | 'RESUME' | 'STOP';
  payload?: {
    initialSeed: number;
    encounterType: EncounterType;
    encounterParams: EncounterParams;
    generationRange: GenerationRange;
    trainerId: number;
    secretId: number;
    synchronize: SynchronizeSettings;
  };
}

// Worker â†’ ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰
interface GenerationWorkerResponse {
  type: 'PROGRESS' | 'RESULT' | 'COMPLETE' | 'ERROR' | 'PAUSED';
  payload?: {
    progress?: GenerationProgress;
    pokemon?: GeneratedPokemon;
    error?: string;
    statistics?: GenerationStatistics;
  };
}
```

## 4. æ ¸å¿ƒã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Ÿè£…

### 4.1 æ€§æ ¼å€¤ä¹±æ•°åˆ—ã‚¨ãƒ³ã‚¸ãƒ³ï¼ˆWASMå®Ÿè£…ï¼‰

**é‡è¦**: è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯ã¯å…¨ã¦WASMå´ã§å®Ÿè£…ã—ã€TypeScriptå´ã¯ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè£…ã‚’è¡Œã‚ãªã„ã€‚

```rust
// wasm-pkg/src/personality_rng.rs
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub struct PersonalityRNG {
    seed: u64,
}

#[wasm_bindgen]
impl PersonalityRNG {
    #[wasm_bindgen(constructor)]
    pub fn new(initial_seed: u64) -> PersonalityRNG {
        PersonalityRNG {
            seed: initial_seed,
        }
    }
    
    // BWä»•æ§˜64bitç·šå½¢åˆåŒæ³•
    // S1[n+1] = S1[n] * 0x5D588B656C078965 + 0x269EC3
    pub fn next(&mut self) -> u32 {
        self.seed = self.seed
            .wrapping_mul(0x5D588B656C078965)
            .wrapping_add(0x269EC3);
        
        // ä¸Šä½32bitã‚’è¿”ã™ï¼ˆå®Ÿéš›ã®ä¹±æ•°ã¨ã—ã¦ä½¿ç”¨ï¼‰
        (self.seed >> 32) as u32
    }
    
    // ã‚·ãƒ³ã‚¯ãƒ­åˆ¤å®šç”¨: (r1[n]*2)>>32
    pub fn sync_check(&mut self) -> bool {
        let rand = self.next();
        ((rand as u64 * 2) >> 32) == 0
    }
    
    // æ€§æ ¼æ±ºå®šç”¨: (r1[n]*25)>>32
    pub fn nature_roll(&mut self) -> u32 {
        let rand = self.next();
        ((rand as u64 * 25) >> 32) as u32
    }
    
    // é­é‡ã‚¹ãƒ­ãƒƒãƒˆæ±ºå®šï¼ˆBWç”¨ï¼‰: (seed*0xFFFF/0x290)>>32
    pub fn encounter_slot_bw(&mut self) -> u32 {
        let rand = self.next();
        ((rand as u64 * 0xFFFF / 0x290) >> 32) as u32
    }
    
    // é­é‡ã‚¹ãƒ­ãƒƒãƒˆæ±ºå®šï¼ˆBW2ç”¨ï¼‰: (seed*100)>>32
    pub fn encounter_slot_bw2(&mut self) -> u32 {
        let rand = self.next();
        ((rand as u64 * 100) >> 32) as u32
    }
    
    #[wasm_bindgen(getter)]
    pub fn current_seed(&self) -> u64 {
        self.seed
    }
    
    #[wasm_bindgen(setter)]
    pub fn set_seed(&mut self, seed: u64) {
        self.seed = seed;
    }
}
```

### 4.3 çµ±åˆPokemon Generatorï¼ˆWASMå®Ÿè£…ï¼‰

```rust
// wasm-pkg/src/pokemon_generator.rs
use wasm_bindgen::prelude::*;
use crate::personality_rng::PersonalityRNG;
use crate::encounter_calculator::{EncounterCalculator, GameVersion};
use crate::pokemon_data::RawPokemonData;

#[wasm_bindgen]
pub struct PokemonGenerator {
    rng: PersonalityRNG,
    encounter_calc: EncounterCalculator,
    game_version: GameVersion,
}

#[wasm_bindgen]
impl PokemonGenerator {
    #[wasm_bindgen(constructor)]
    pub fn new(initial_seed: u64, game_version: GameVersion) -> PokemonGenerator {
        PokemonGenerator {
            rng: PersonalityRNG::new(initial_seed),
            encounter_calc: EncounterCalculator::new(game_version),
            game_version,
        }
    }
    
    // ãƒ¡ã‚¤ãƒ³ç”Ÿæˆãƒ¡ã‚½ãƒƒãƒ‰
    pub fn generate_pokemon_batch(
        &mut self,
        count: u32,
        encounter_type: u32,
        sync_enabled: bool,
        sync_nature_id: u32,
        trainer_id: u16,
        secret_id: u16,
    ) -> Vec<RawPokemonData> {
        let mut results = Vec::new();
        
        for advances in 0..count {
            if let Some(pokemon) = self.generate_single_pokemon(
                encounter_type,
                sync_enabled,
                sync_nature_id,
                trainer_id,
                secret_id,
                advances,
            ) {
                results.push(pokemon);
            }
        }
        
        results
    }
    
    fn generate_single_pokemon(
        &mut self,
        encounter_type: u32,
        sync_enabled: bool,
        sync_nature_id: u32,
        trainer_id: u16,
        secret_id: u16,
        advances: u32,
    ) -> Option<RawPokemonData> {
        let start_seed = self.rng.current_seed();
        
        // Step 1: ã‚·ãƒ³ã‚¯ãƒ­åˆ¤å®šï¼ˆå›ºå®šã‚·ãƒ³ãƒœãƒ«ãƒ»é‡ç”Ÿã®ã¿ï¼‰
        let (sync_applied, nature_id) = if encounter_type <= 1 {
            let sync_check = sync_enabled && self.rng.sync_check();
            if sync_check {
                (true, sync_nature_id)
            } else {
                (false, self.rng.nature_roll())
            }
        } else {
            // å¾˜å¾Šãƒã‚±ãƒ¢ãƒ³ã¯ã‚·ãƒ³ã‚¯ãƒ­ç„¡åŠ¹
            (false, self.rng.nature_roll())
        };
        
        // Step 2: é­é‡ã‚¹ãƒ­ãƒƒãƒˆæ±ºå®š
        let encounter_slot_value = match self.game_version {
            GameVersion::BlackWhite => self.rng.encounter_slot_bw(),
            GameVersion::BlackWhite2 => self.rng.encounter_slot_bw2(),
        };
        
        // Step 3: æ€§æ ¼å€¤æ±ºå®š
        let personality_value = match encounter_type {
            0 | 1 => {
                // é‡ç”Ÿãƒ»å›ºå®šã‚·ãƒ³ãƒœãƒ«: r1[n+1]^0x00010000
                let pid_base = self.rng.next();
                pid_base ^ 0x00010000
            },
            2 => {
                // å¾˜å¾Šãƒã‚±ãƒ¢ãƒ³: r1[n] (XORç„¡ã—)
                self.rng.next()
            },
            _ => return None, // æœªå¯¾å¿œã®ã‚¨ãƒ³ã‚«ã‚¦ãƒ³ãƒˆã‚¿ã‚¤ãƒ—
        };
        
        // Step 4: ãƒ¬ãƒ™ãƒ«æ±ºå®šï¼ˆç°¡æ˜“å®Ÿè£…ã€å®Ÿéš›ã¯é­é‡ãƒ†ãƒ¼ãƒ–ãƒ«ä¾å­˜ï¼‰
        let level = self.calculate_level(encounter_slot_value, encounter_type);
        
        // Step 5: è‰²é•ã„åˆ¤å®š
        let shiny_flag = self.check_shiny(personality_value, trainer_id, secret_id);
        
        // Step 6: ç‰¹æ€§ã‚¹ãƒ­ãƒƒãƒˆæ±ºå®š
        let ability_slot = if (personality_value >> 16) & 1 == 0 { 1 } else { 2 };
        
        // Step 7: æ€§åˆ¥åˆ¤å®šå€¤
        let gender_value = (personality_value & 0xFF) as u8;
        
        Some(RawPokemonData {
            personality_value,
            encounter_slot_value,
            nature_id,
            sync_applied,
            advances,
            level,
            shiny_flag,
            ability_slot,
            gender_value,
            rng_seed_used: start_seed,
            encounter_type,
        })
    }
    
    fn calculate_level(&mut self, slot_value: u32, encounter_type: u32) -> u8 {
        // ç°¡æ˜“å®Ÿè£…ï¼šå®Ÿéš›ã¯ã‚¨ãƒ³ã‚«ã‚¦ãƒ³ãƒˆãƒ†ãƒ¼ãƒ–ãƒ«ã¨ãƒ¬ãƒ™ãƒ«ç¯„å›²ã«ä¾å­˜
        match encounter_type {
            0 => 25, // è‰ã‚€ã‚‰ï¼šå›ºå®šãƒ¬ãƒ™ãƒ«ä¾‹
            1 => {
                // ãªã¿ã®ã‚Šï¼šãƒ¬ãƒ™ãƒ«ç¯„å›²ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ é¸æŠ
                let level_rand = self.rng.next();
                let min_lv = 25;
                let max_lv = 35;
                ((level_rand as u64 * (max_lv - min_lv + 1) as u64) >> 32) as u8 + min_lv
            },
            2 => 30, // å¾˜å¾Šï¼šå›ºå®šãƒ¬ãƒ™ãƒ«
            _ => 25,
        }
    }
    
    fn check_shiny(&self, pid: u32, trainer_id: u16, secret_id: u16) -> bool {
        let pid_high = (pid >> 16) as u16;
        let pid_low = (pid & 0xFFFF) as u16;
        let shiny_value = trainer_id ^ secret_id ^ pid_high ^ pid_low;
        shiny_value < 8
    }
    
    #[wasm_bindgen(getter)]
    pub fn current_seed(&self) -> u64 {
        self.rng.current_seed()
    }
    
    #[wasm_bindgen(setter)]
    pub fn set_seed(&mut self, seed: u64) {
        self.rng.set_seed(seed);
    }
}
```
```

## 5. æ€§æ ¼å€¤ãƒ»è‰²é•ã„åˆ¤å®šã®è©³ç´°å®Ÿè£…

### 5.1 æ€§æ ¼å€¤ï¼ˆPIDï¼‰ç”Ÿæˆã®æ­£ç¢ºãªä»•æ§˜

BWã«ãŠã‘ã‚‹æ€§æ ¼å€¤ç”Ÿæˆã¯é­é‡ã‚¿ã‚¤ãƒ—ã«ã‚ˆã£ã¦ç•°ãªã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’ä½¿ç”¨ã™ã‚‹ã€‚

```rust
// wasm-pkg/src/pid_generation.rs
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub struct PIDGenerator;

#[wasm_bindgen]
impl PIDGenerator {
    // é‡ç”Ÿãƒã‚±ãƒ¢ãƒ³ãƒ»å›ºå®šã‚·ãƒ³ãƒœãƒ«ç”¨PIDç”Ÿæˆ
    pub fn generate_wild_static_pid(rng: &mut PersonalityRNG) -> u32 {
        // BWä»•æ§˜: r1[n+1] ^ 0x00010000
        let pid_base = rng.next();
        pid_base ^ 0x00010000
    }
    
    // ä¸€éƒ¨ã®å›ºå®šã‚·ãƒ³ãƒœãƒ«ç”¨PIDç”Ÿæˆï¼ˆç‰¹æ®Šã‚±ãƒ¼ã‚¹ï¼‰
    pub fn generate_special_static_pid(rng: &mut PersonalityRNG) -> u32 {
        // ç‰¹æ®Šã‚±ãƒ¼ã‚¹: r1[n+1] ^ 0x80010000
        let pid_base = rng.next();
        pid_base ^ 0x80010000
    }
    
    // å¾˜å¾Šãƒã‚±ãƒ¢ãƒ³ç”¨PIDç”Ÿæˆ
    pub fn generate_roaming_pid(rng: &mut PersonalityRNG) -> u32 {
        // å¾˜å¾Š: r1[n] (XORå‡¦ç†ãªã—)
        rng.next()
    }
    
    // ã‚¿ãƒã‚´ç”¨PIDç”Ÿæˆï¼ˆå‚è€ƒå®Ÿè£…ï¼‰
    pub fn generate_egg_pid(rng: &mut PersonalityRNG) -> u32 {
        // ã‚¿ãƒã‚´: ç‰¹æ®Šãªç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯ï¼ˆä»Šå›ã¯å¯¾è±¡å¤–ï¼‰
        // å®Ÿè£…æ™‚ã«ã¯åˆ¥ã®è¨ˆç®—ãŒå¿…è¦
        rng.next()
    }
}

#[wasm_bindgen]
pub struct ShinyChecker;

#[wasm_bindgen]
impl ShinyChecker {
    // è‰²é•ã„åˆ¤å®šã®è©³ç´°å®Ÿè£…
    pub fn is_shiny(pid: u32, trainer_id: u16, secret_id: u16) -> bool {
        let pid_high = (pid >> 16) as u16;
        let pid_low = (pid & 0xFFFF) as u16;
        
        // è‰²é•ã„å€¤è¨ˆç®—: TID ^ SID ^ PIDHigh ^ PIDLow
        let shiny_value = trainer_id ^ secret_id ^ pid_high ^ pid_low;
        
        // BW: è‰²é•ã„å€¤ãŒ8æœªæº€ã§è‰²é•ã„ï¼ˆ1/8192ç¢ºç‡ï¼‰
        shiny_value < 8
    }
    
    // ãƒ‡ãƒãƒƒã‚°ç”¨: è‰²é•ã„å€¤ã‚’è¿”ã™
    pub fn get_shiny_value(pid: u32, trainer_id: u16, secret_id: u16) -> u16 {
        let pid_high = (pid >> 16) as u16;
        let pid_low = (pid & 0xFFFF) as u16;
        trainer_id ^ secret_id ^ pid_high ^ pid_low
    }
    
    // è‰²é•ã„ã®ç¨®é¡åˆ¤å®š
    pub fn get_shiny_type(pid: u32, trainer_id: u16, secret_id: u16) -> u32 {
        let shiny_value = Self::get_shiny_value(pid, trainer_id, secret_id);
        
        match shiny_value {
            0 => 2,      // Square Shiny (æ­£æ–¹å½¢)
            1..=7 => 1,  // Star Shiny (æ˜Ÿå‹)
            _ => 0,      // Not Shiny
        }
    }
}
```

### 5.2 é­é‡ã‚¿ã‚¤ãƒ—åˆ¥PIDç”Ÿæˆãƒ‘ã‚¿ãƒ¼ãƒ³

```rust
impl PokemonGenerator {
    fn generate_pid_by_encounter_type(&mut self, encounter_type: u32) -> u32 {
        match encounter_type {
            0 => {
                // è‰ã‚€ã‚‰é‡ç”Ÿãƒã‚±ãƒ¢ãƒ³
                PIDGenerator::generate_wild_static_pid(&mut self.rng)
            },
            1 => {
                // å›ºå®šã‚·ãƒ³ãƒœãƒ«ï¼ˆé€šå¸¸ï¼‰
                PIDGenerator::generate_wild_static_pid(&mut self.rng)
            },
            2 => {
                // å¾˜å¾Šãƒã‚±ãƒ¢ãƒ³ï¼ˆãƒœãƒ«ãƒˆãƒ­ã‚¹ãƒ»ãƒˆãƒ«ãƒãƒ­ã‚¹ï¼‰
                PIDGenerator::generate_roaming_pid(&mut self.rng)
            },
            3 => {
                // ãªã¿ã®ã‚Š
                PIDGenerator::generate_wild_static_pid(&mut self.rng)
            },
            4 => {
                // ã¤ã‚Š
                PIDGenerator::generate_wild_static_pid(&mut self.rng)
            },
            5 => {
                // ç ‚ç…™
                PIDGenerator::generate_wild_static_pid(&mut self.rng)
            },
            6 => {
                // ç‰¹æ®Šå›ºå®šã‚·ãƒ³ãƒœãƒ«ï¼ˆä¸€éƒ¨ã®ãƒ¬ã‚¸ã‚§ãƒ³ãƒ€ãƒªãƒ¼ï¼‰
                PIDGenerator::generate_special_static_pid(&mut self.rng)
            },
            _ => {
                // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
                PIDGenerator::generate_wild_static_pid(&mut self.rng)
            }
        }
    }
}
```

## 6. é­é‡ã‚¿ã‚¤ãƒ—åˆ¥ä¹±æ•°æ¶ˆè²»ãƒ‘ã‚¿ãƒ¼ãƒ³ã®è©³ç´°

### 6.1 æ¶ˆè²»é †åºã®æ­£ç¢ºãªä»•æ§˜

BWã«ãŠã‘ã‚‹ä¹±æ•°æ¶ˆè²»ã¯é­é‡ã‚¿ã‚¤ãƒ—ã«ã‚ˆã£ã¦å³å¯†ã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã€‚

```rust
// wasm-pkg/src/encounter_patterns.rs
use wasm_bindgen::prelude::*;
use crate::personality_rng::PersonalityRNG;

#[wasm_bindgen]
pub struct EncounterPattern;

#[wasm_bindgen]
impl EncounterPattern {
    // é‡ç”Ÿãƒã‚±ãƒ¢ãƒ³ï¼ˆè‰ã‚€ã‚‰ï¼‰ã®æ¶ˆè²»ãƒ‘ã‚¿ãƒ¼ãƒ³
    // ã‚·ãƒ³ã‚¯ãƒ­åˆ¤å®š â†’ å‡ºç¾ãƒã‚±ãƒ¢ãƒ³æ±ºå®š â†’ ã‚¹ã‚­ãƒƒãƒ— â†’ æ€§æ ¼å€¤æ±ºå®š â†’ æ€§æ ¼æ±ºå®š
    pub fn wild_grass_pattern(
        rng: &mut PersonalityRNG,
        sync_enabled: bool,
        sync_nature_id: u32,
    ) -> EncounterResult {
        // Step 1: ã‚·ãƒ³ã‚¯ãƒ­åˆ¤å®š (1æ¶ˆè²»)
        let sync_applied = sync_enabled && rng.sync_check();
        
        // Step 2: å‡ºç¾ãƒã‚±ãƒ¢ãƒ³æ±ºå®š (1æ¶ˆè²»)
        let encounter_slot = rng.encounter_slot_bw(); // ã¾ãŸã¯bw2
        
        // Step 3: ã‚¹ã‚­ãƒƒãƒ— (1æ¶ˆè²»)
        rng.next(); // ã“ã®å€¤ã¯ä½¿ç”¨ã•ã‚Œãªã„
        
        // Step 4: æ€§æ ¼å€¤æ±ºå®š (1æ¶ˆè²»)
        let pid = rng.next() ^ 0x00010000;
        
        // Step 5: æ€§æ ¼æ±ºå®š (1æ¶ˆè²»ã€ã‚·ãƒ³ã‚¯ãƒ­ä¸ç™ºæ™‚ã®ã¿)
        let nature_id = if sync_applied {
            sync_nature_id
        } else {
            rng.nature_roll()
        };
        
        // åˆè¨ˆ: 5æ¶ˆè²»ï¼ˆã‚·ãƒ³ã‚¯ãƒ­æˆåŠŸæ™‚ï¼‰/ 5æ¶ˆè²»ï¼ˆã‚·ãƒ³ã‚¯ãƒ­å¤±æ•—æ™‚ï¼‰
        EncounterResult {
            pid,
            encounter_slot,
            nature_id,
            sync_applied,
            total_consumption: 5,
        }
    }
    
    // å›ºå®šã‚·ãƒ³ãƒœãƒ«ã®æ¶ˆè²»ãƒ‘ã‚¿ãƒ¼ãƒ³
    // é‡ç”Ÿã¨åŒã˜ãƒ‘ã‚¿ãƒ¼ãƒ³
    pub fn static_symbol_pattern(
        rng: &mut PersonalityRNG,
        sync_enabled: bool,
        sync_nature_id: u32,
    ) -> EncounterResult {
        // å›ºå®šã‚·ãƒ³ãƒœãƒ«ã¯é‡ç”Ÿã¨åŒã˜æ¶ˆè²»ãƒ‘ã‚¿ãƒ¼ãƒ³
        Self::wild_grass_pattern(rng, sync_enabled, sync_nature_id)
    }
    
    // å¾˜å¾Šãƒã‚±ãƒ¢ãƒ³ã®æ¶ˆè²»ãƒ‘ã‚¿ãƒ¼ãƒ³
    // æ€§æ ¼å€¤æ±ºå®š â†’ æ€§æ ¼æ±ºå®šï¼ˆã‚·ãƒ³ã‚¯ãƒ­ç„¡åŠ¹ï¼‰
    pub fn roaming_pattern(rng: &mut PersonalityRNG) -> EncounterResult {
        // Step 1: æ€§æ ¼å€¤æ±ºå®š (1æ¶ˆè²»ã€XORç„¡ã—)
        let pid = rng.next();
        
        // Step 2: æ€§æ ¼æ±ºå®š (1æ¶ˆè²»)
        let nature_id = rng.nature_roll();
        
        // åˆè¨ˆ: 2æ¶ˆè²»
        EncounterResult {
            pid,
            encounter_slot: 0, // å¾˜å¾Šã¯é­é‡ã‚¹ãƒ­ãƒƒãƒˆç„¡ã—
            nature_id,
            sync_applied: false, // ã‚·ãƒ³ã‚¯ãƒ­ç„¡åŠ¹
            total_consumption: 2,
        }
    }
    
    // ãªã¿ã®ã‚Šãƒ»ã¤ã‚Šã®æ¶ˆè²»ãƒ‘ã‚¿ãƒ¼ãƒ³
    // ã‚·ãƒ³ã‚¯ãƒ­åˆ¤å®š â†’ å‡ºç¾ãƒã‚±ãƒ¢ãƒ³æ±ºå®š â†’ ãƒ¬ãƒ™ãƒ«æ±ºå®š â†’ æ€§æ ¼å€¤æ±ºå®š â†’ æ€§æ ¼æ±ºå®š
    pub fn surfing_fishing_pattern(
        rng: &mut PersonalityRNG,
        sync_enabled: bool,
        sync_nature_id: u32,
        game_version: GameVersion,
    ) -> EncounterResult {
        // Step 1: ã‚·ãƒ³ã‚¯ãƒ­åˆ¤å®š (1æ¶ˆè²»)
        let sync_applied = sync_enabled && rng.sync_check();
        
        // Step 2: å‡ºç¾ãƒã‚±ãƒ¢ãƒ³æ±ºå®š (1æ¶ˆè²»)
        let encounter_slot = match game_version {
            GameVersion::BlackWhite => rng.encounter_slot_bw(),
            GameVersion::BlackWhite2 => rng.encounter_slot_bw2(),
        };
        
        // Step 3: ãƒ¬ãƒ™ãƒ«æ±ºå®š (1æ¶ˆè²»)
        let level_rand = rng.next();
        
        // Step 4: æ€§æ ¼å€¤æ±ºå®š (1æ¶ˆè²»)
        let pid = rng.next() ^ 0x00010000;
        
        // Step 5: æ€§æ ¼æ±ºå®š (1æ¶ˆè²»ã€ã‚·ãƒ³ã‚¯ãƒ­ä¸ç™ºæ™‚ã®ã¿)
        let nature_id = if sync_applied {
            sync_nature_id
        } else {
            rng.nature_roll()
        };
        
        // åˆè¨ˆ: 5æ¶ˆè²»ï¼ˆã‚·ãƒ³ã‚¯ãƒ­æˆåŠŸæ™‚ï¼‰/ 5æ¶ˆè²»ï¼ˆã‚·ãƒ³ã‚¯ãƒ­å¤±æ•—æ™‚ï¼‰
        EncounterResult {
            pid,
            encounter_slot,
            nature_id,
            sync_applied,
            total_consumption: 5,
        }
    }
    
    // å¤§é‡ç™ºç”Ÿã®æ¶ˆè²»ãƒ‘ã‚¿ãƒ¼ãƒ³
    // é€šå¸¸é‡ç”Ÿ + å¤§é‡ç™ºç”Ÿåˆ¤å®š
    pub fn mass_outbreak_pattern(
        rng: &mut PersonalityRNG,
        sync_enabled: bool,
        sync_nature_id: u32,
    ) -> EncounterResult {
        // Step 1: å¤§é‡ç™ºç”Ÿåˆ¤å®š (1æ¶ˆè²»)
        let outbreak_check = rng.next();
        let is_outbreak_pokemon = (outbreak_check as u64 * 100) >> 32 < 40; // 40%ã§å¤§é‡ç™ºç”Ÿ
        
        // Step 2-6: é€šå¸¸é‡ç”Ÿã¨åŒã˜ãƒ‘ã‚¿ãƒ¼ãƒ³ (5æ¶ˆè²»)
        let mut result = Self::wild_grass_pattern(rng, sync_enabled, sync_nature_id);
        
        // å¤§é‡ç™ºç”Ÿæ™‚ã¯é­é‡ã‚¹ãƒ­ãƒƒãƒˆã‚’æ›¸ãæ›ãˆ
        if is_outbreak_pokemon {
            result.encounter_slot = 100; // å¤§é‡ç™ºç”Ÿå°‚ç”¨ã‚¹ãƒ­ãƒƒãƒˆ
        }
        
        result.total_consumption += 1; // å¤§é‡ç™ºç”Ÿåˆ¤å®šåˆ†
        result
    }
}

#[wasm_bindgen]
pub struct EncounterResult {
    pub pid: u32,
    pub encounter_slot: u32,
    pub nature_id: u32,
    pub sync_applied: bool,
    pub total_consumption: u32,
}
```

### 6.2 æ¶ˆè²»ãƒ‘ã‚¿ãƒ¼ãƒ³ä¸€è¦§è¡¨

| é­é‡ã‚¿ã‚¤ãƒ— | æ¶ˆè²»é †åº | ç·æ¶ˆè²»æ•° | å‚™è€ƒ |
|-----------|---------|----------|------|
| è‰ã‚€ã‚‰é‡ç”Ÿ | ã‚·ãƒ³ã‚¯ãƒ­â†’å‡ºç¾â†’ã‚¹ã‚­ãƒƒãƒ—â†’æ€§æ ¼å€¤â†’æ€§æ ¼ | 5 | ã‚¹ã‚­ãƒƒãƒ—ã¯å›ºå®š |
| å›ºå®šã‚·ãƒ³ãƒœãƒ« | ã‚·ãƒ³ã‚¯ãƒ­â†’å‡ºç¾â†’ã‚¹ã‚­ãƒƒãƒ—â†’æ€§æ ¼å€¤â†’æ€§æ ¼ | 5 | é‡ç”Ÿã¨åŒæ§˜ |
| å¾˜å¾Šãƒã‚±ãƒ¢ãƒ³ | æ€§æ ¼å€¤â†’æ€§æ ¼ | 2 | ã‚·ãƒ³ã‚¯ãƒ­ç„¡åŠ¹ |
| ãªã¿ã®ã‚Š | ã‚·ãƒ³ã‚¯ãƒ­â†’å‡ºç¾â†’ãƒ¬ãƒ™ãƒ«â†’æ€§æ ¼å€¤â†’æ€§æ ¼ | 5 | ãƒ¬ãƒ™ãƒ«åˆ¤å®šè¿½åŠ  |
| ã¤ã‚Š | ã‚·ãƒ³ã‚¯ãƒ­â†’å‡ºç¾â†’ãƒ¬ãƒ™ãƒ«â†’æ€§æ ¼å€¤â†’æ€§æ ¼ | 5 | ãªã¿ã®ã‚Šã¨åŒæ§˜ |
| ç ‚ç…™ | ã‚·ãƒ³ã‚¯ãƒ­â†’å‡ºç¾â†’ã‚¹ã‚­ãƒƒãƒ—â†’æ€§æ ¼å€¤â†’æ€§æ ¼ | 5 | è‰ã‚€ã‚‰ã¨åŒæ§˜ |
| å¤§é‡ç™ºç”Ÿ | å¤§é‡ç™ºç”Ÿåˆ¤å®šâ†’(é€šå¸¸é‡ç”Ÿãƒ‘ã‚¿ãƒ¼ãƒ³) | 6 | åˆ¤å®š1æ¶ˆè²»è¿½åŠ  |

### 6.3 çµ±åˆç”Ÿæˆã‚¨ãƒ³ã‚¸ãƒ³ã§ã®å®Ÿè£…

```rust
impl PokemonGenerator {
    fn generate_by_encounter_type(
        &mut self,
        encounter_type: u32,
        sync_enabled: bool,
        sync_nature_id: u32,
    ) -> EncounterResult {
        match encounter_type {
            0 => {
                // è‰ã‚€ã‚‰é‡ç”Ÿ
                EncounterPattern::wild_grass_pattern(
                    &mut self.rng, sync_enabled, sync_nature_id
                )
            },
            1 => {
                // å›ºå®šã‚·ãƒ³ãƒœãƒ«
                EncounterPattern::static_symbol_pattern(
                    &mut self.rng, sync_enabled, sync_nature_id
                )
            },
            2 => {
                // å¾˜å¾Šãƒã‚±ãƒ¢ãƒ³
                EncounterPattern::roaming_pattern(&mut self.rng)
            },
            3 | 4 => {
                // ãªã¿ã®ã‚Šãƒ»ã¤ã‚Š
                EncounterPattern::surfing_fishing_pattern(
                    &mut self.rng, sync_enabled, sync_nature_id, self.game_version
                )
            },
            5 => {
                // ç ‚ç…™
                EncounterPattern::wild_grass_pattern(
                    &mut self.rng, sync_enabled, sync_nature_id
                )
            },
            6 => {
                // å¤§é‡ç™ºç”Ÿ
                EncounterPattern::mass_outbreak_pattern(
                    &mut self.rng, sync_enabled, sync_nature_id
                )
            },
            _ => {
                // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼ˆé‡ç”Ÿæ‰±ã„ï¼‰
                EncounterPattern::wild_grass_pattern(
                    &mut self.rng, sync_enabled, sync_nature_id
                )
            }
        }
    }
}

## 7. ãƒ‡ãƒ¼ã‚¿ç®¡ç†å®Ÿè£…ï¼ˆTypeScriptå´ï¼‰

### 7.1 Generation Data Manager

```typescript
// src/lib/generation/data-manager.ts
export class GenerationDataManager {
  private speciesData: Map<string, PokemonSpeciesData> = new Map();
  private encounterTables: Map<string, EncounterTable> = new Map();
  private abilityData: Map<string, AbilityData> = new Map();
  private gameConstants: GameConstants;
  
  constructor(gameVersion: GameVersion) {
    this.gameConstants = this.loadGameConstants(gameVersion);
  }
  
  async initialize(): Promise<void> {
    await Promise.all([
      this.loadSpeciesData(),
      this.loadEncounterTables(),
      this.loadAbilityData(),
    ]);
  }
  
  private async loadSpeciesData(): Promise<void> {
    const response = await fetch('/data/generation/species/gen5-species.json');
    const data = await response.json();
    
    for (const species of data.species) {
      this.speciesData.set(species.name.toLowerCase(), species);
    }
  }
  
  private async loadEncounterTables(): Promise<void> {
    const response = await fetch('/data/generation/encounters/gen5-encounters.json');
    const data = await response.json();
    
    for (const [locationId, table] of Object.entries(data.tables)) {
      this.encounterTables.set(locationId, table as EncounterTable);
    }
  }
  
  private async loadAbilityData(): Promise<void> {
    const response = await fetch('/data/generation/abilities/gen5-abilities.json');
    const data = await response.json();
    
    for (const ability of data.abilities) {
      this.abilityData.set(ability.name.toLowerCase(), ability);
    }
  }
  
  // ç¨®æ—ãƒ‡ãƒ¼ã‚¿å–å¾—
  getSpecies(name: string): PokemonSpeciesData | undefined {
    return this.speciesData.get(name.toLowerCase());
  }
  
  // é­é‡ãƒ†ãƒ¼ãƒ–ãƒ«å–å¾—
  getEncounterTable(locationId: string): EncounterTable | undefined {
    return this.encounterTables.get(locationId);
  }
  
  // ç‰¹æ€§ãƒ‡ãƒ¼ã‚¿å–å¾—
  getAbility(name: string): AbilityData | undefined {
    return this.abilityData.get(name.toLowerCase());
  }
  
  // é­é‡ã‚¹ãƒ­ãƒƒãƒˆã‹ã‚‰ãƒã‚±ãƒ¢ãƒ³ç¨®æ—ã‚’ç‰¹å®š
  getSpeciesFromSlot(slotIndex: number, encounterTable: EncounterTable): string {
    if (slotIndex >= encounterTable.slots.length) {
      throw new Error(`Invalid slot index: ${slotIndex}`);
    }
    
    return encounterTable.slots[slotIndex].pokemon;
  }
  
  // æ€§åˆ¥æ¯”ç‡ã®é–¾å€¤å–å¾—
  getGenderThreshold(species: string): number {
    const speciesData = this.getSpecies(species);
    if (!speciesData) return 127; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ50:50
    
    const ratioMap: Record<string, number> = {
      'genderless': -1,
      'male-only': 256,
      'female-only': 0,
      '87.5:12.5': 31,   // 87.5% male (starterç­‰)
      '75:25': 63,       // 75% male
      '50:50': 127,      // 50% male
      '25:75': 191,      // 25% male
      '12.5:87.5': 225,  // 12.5% male
    };
    
    return ratioMap[speciesData.genderRatio] ?? 127;
  }
  
  // ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
  validateDataIntegrity(): ValidationResult {
    const errors: string[] = [];
    
    // é­é‡ãƒ†ãƒ¼ãƒ–ãƒ«ã®å‚ç…§æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
    for (const [locationId, table] of this.encounterTables) {
      for (const slot of table.slots) {
        if (!this.speciesData.has(slot.pokemon.toLowerCase())) {
          errors.push(`Unknown pokemon: ${slot.pokemon} in ${locationId}`);
        }
        
        // ç‰¹æ€§ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
        const species = this.getSpecies(slot.pokemon);
        if (species) {
          if (!this.abilityData.has(species.abilities.ability1.toLowerCase())) {
            errors.push(`Unknown ability1: ${species.abilities.ability1} for ${slot.pokemon}`);
          }
          if (species.abilities.ability2 && !this.abilityData.has(species.abilities.ability2.toLowerCase())) {
            errors.push(`Unknown ability2: ${species.abilities.ability2} for ${slot.pokemon}`);
          }
        }
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }
  
  private loadGameConstants(gameVersion: GameVersion): GameConstants {
    // ã‚²ãƒ¼ãƒ ãƒãƒ¼ã‚¸ãƒ§ãƒ³åˆ¥ã®å®šæ•°
    const constants = {
      [GameVersion.BlackWhite]: {
        encounterSlotDivisor: 0x290,
        encounterSlotMultiplier: 0xFFFF,
        vcount: { black: 0x60, white: 0x5f },
        nazo: { black: 0x2215f10, white: 0x2215f30 },
      },
      [GameVersion.BlackWhite2]: {
        encounterSlotDivisor: 1,
        encounterSlotMultiplier: 100,
        vcount: { black2: 0x60, white2: 0x5f }, // è¦ç¢ºèª
        nazo: { black2: 0x2215f10, white2: 0x2215f30 }, // è¦ç¢ºèª
      }
    };
    
    return constants[gameVersion];
  }
}

// å‹å®šç¾©
interface PokemonSpeciesData {
  name: string;
  pokedexNumber: number;
  types: { type1: string; type2?: string };
  baseStats: { hp: number; attack: number; defense: number; specialAttack: number; specialDefense: number; speed: number };
  abilities: { ability1: string; ability2?: string; hiddenAbility?: string };
  genderRatio: string;
  catchRate: number;
  baseExperience: number;
}

interface EncounterTable {
  location: string;
  encounterType: string;
  levelRange: { min: number; max: number };
  slots: EncounterSlot[];
}

interface EncounterSlot {
  index: number;
  pokemon: string;
  probability: number;
  levelRange?: { min: number; max: number };
}

interface AbilityData {
  name: string;
  description: string;
  effect: string;
}

interface ValidationResult {
  isValid: boolean;
  errors: string[];
}

interface GameConstants {
  encounterSlotDivisor: number;
  encounterSlotMultiplier: number;
  vcount: Record<string, number>;
  nazo: Record<string, number>;
}
```

---

**ä½œæˆæ—¥**: 2025å¹´8æœˆ2æ—¥  
**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 1.0  
**ä½œæˆè€…**: GitHub Copilot  
**ä¾å­˜**: pokemon-generation-feature-spec.md, pokemon-data-specification.md, pokemon-generation-ui-spec.md

### 9.1 WASM Layer Tests

#### 9.1.1 RNG Engine Tests
```rust
// wasm-pkg/src/tests/rng_tests.rs
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_64bit_lcg_sequence() {
        let mut rng = PersonalityRNG::new(0x12345678ABCDEF12);
        
        // æ—¢çŸ¥ã®seedå€¤ã‹ã‚‰æœŸå¾…ã•ã‚Œã‚‹ä¹±æ•°åˆ—ã‚’ç¢ºèª
        let expected_sequence = [
            0x9A7B2C3D, 0x4E5F6A8B, 0xC1D2E3F4, 0x5678A9BC
        ];
        
        for &expected in &expected_sequence {
            assert_eq!(rng.next(), expected);
        }
    }
    
    #[test]
    fn test_encounter_slot_calculation() {
        let mut rng = PersonalityRNG::new(0x12345678);
        let calc = EncounterCalculator::new(GameVersion::BlackWhite);
        
        // BW: (seed*0xFFFF/0x290)>>32
        let slot = calc.calculate_encounter_slot(rng.next());
        assert!(slot < 12); // é­é‡ã‚¹ãƒ­ãƒƒãƒˆã¯0-11
    }
    
    #[test]
    fn test_shiny_calculation() {
        let pid = 0x12345678;
        let trainer_id = 12345;
        let secret_id = 54321;
        
        let shiny_value = ShinyChecker::get_shiny_value(pid, trainer_id, secret_id);
        let is_shiny = ShinyChecker::is_shiny(pid, trainer_id, secret_id);
        
        assert_eq!(is_shiny, shiny_value < 8);
    }
}
```

#### 9.1.2 Reference Implementation Tests
```rust
#[test]
fn test_against_reference_implementation() {
    // æ—¢çŸ¥ã®ãƒ„ãƒ¼ãƒ«ï¼ˆã•ã³ãŸã‚³ã‚¤ãƒ«ç­‰ï¼‰ã¨ã®çµæœæ¯”è¼ƒ
    let test_cases = [
        TestCase {
            initial_seed: 0x12345678ABCDEF12,
            encounter_type: 0, // é‡ç”Ÿ
            sync_enabled: false,
            expected_results: vec![
                ExpectedPokemon {
                    advances: 100,
                    pid: 0x12345678,
                    nature_id: 5,
                    encounter_slot: 3,
                    is_shiny: false,
                },
                // è¿½åŠ ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹...
            ]
        }
    ];
    
    for test_case in test_cases {
        let mut generator = PokemonGenerator::new(
            test_case.initial_seed, 
            GameVersion::BlackWhite
        );
        
        for expected in test_case.expected_results {
            // advanceså›åˆ†ã®è¨ˆç®—ã‚’å®Ÿè¡Œ
            for _ in 0..expected.advances {
                let result = generator.generate_single_pokemon(
                    test_case.encounter_type,
                    test_case.sync_enabled,
                    0, // sync_nature_id
                    12345, // trainer_id
                    54321, // secret_id
                    expected.advances,
                );
                
                if let Some(pokemon) = result {
                    assert_eq!(pokemon.personality_value, expected.pid);
                    assert_eq!(pokemon.nature_id, expected.nature_id);
                    assert_eq!(pokemon.encounter_slot_value, expected.encounter_slot);
                    assert_eq!(pokemon.shiny_flag, expected.is_shiny);
                }
            }
        }
    }
}
```

### 9.2 TypeScript Integration Tests

#### 9.2.1 Data Parser Tests
```typescript
// src/test/result-parser.test.ts
describe('PokemonResultParser', () => {
  let parser: PokemonResultParser;
  let dataManager: GenerationDataManager;
  
  beforeEach(async () => {
    dataManager = new GenerationDataManager(GameVersion.BlackWhite);
    await dataManager.initialize();
    parser = new PokemonResultParser(dataManager, GameVersion.BlackWhite);
  });
  
  test('should parse WASM output correctly', () => {
    const rawData = new RawPokemonData();
    rawData.personality_value = 0x12345678;
    rawData.encounter_slot_value = 3;
    rawData.nature_id = 5;
    rawData.sync_applied = false;
    
    const encounterParams = {
      location: 'route-1',
      type: 0, // é‡ç”Ÿ
      timeOfDay: 'day',
      season: 'spring'
    };
    
    const result = parser.parseRawData(rawData, encounterParams);
    
    expect(result.species).toBe('Patrat'); // route-1ã®3ç•ªã‚¹ãƒ­ãƒƒãƒˆ
    expect(result.nature).toBe('Impish'); // nature_id 5
    expect(result.ability.name).toBeDefined();
    expect(result.gender).toMatch(/^(male|female|genderless)$/);
  });
  
  test('should handle synchronize correctly', () => {
    const rawData = new RawPokemonData();
    rawData.sync_applied = true;
    rawData.nature_id = 3; // Adamant
    
    const result = parser.parseRawData(rawData, mockEncounterParams);
    
    expect(result.synchronizeApplied).toBe(true);
    expect(result.nature).toBe('Adamant');
  });
});
```

#### 9.2.2 WASM Integration Tests
```typescript
// src/test/wasm-integration.test.ts
describe('WASM Integration', () => {
  test('should generate consistent results', async () => {
    const generator = new PokemonGenerator(0x12345678, GameVersion.BlackWhite);
    
    const results1 = generator.generate_pokemon_batch(100, 0, false, 0, 12345, 54321);
    
    // åŒã˜seedã§å†å®Ÿè¡Œ
    generator.set_seed(0x12345678);
    const results2 = generator.generate_pokemon_batch(100, 0, false, 0, 12345, 54321);
    
    expect(results1).toEqual(results2);
  });
  
  test('should respect encounter type differences', async () => {
    const generator = new PokemonGenerator(0x12345678, GameVersion.BlackWhite);
    
    // é‡ç”Ÿã¨å¾˜å¾Šã§ç•°ãªã‚‹çµæœãŒå‡ºã‚‹ã“ã¨ã‚’ç¢ºèª
    const wildResult = generator.generate_single_pokemon(0, false, 0, 12345, 54321, 0);
    generator.set_seed(0x12345678);
    const roamingResult = generator.generate_single_pokemon(2, false, 0, 12345, 54321, 0);
    
    expect(wildResult).not.toEqual(roamingResult);
  });
});
```

### 9.3 E2E Tests

#### 9.3.1 User Workflow Tests
```typescript
// src/test/e2e/generation-workflow.test.ts
describe('Pokemon Generation E2E', () => {
  test('complete generation workflow', async () => {
    // 1. åˆæœŸè¨­å®š
    const params = {
      gameVersion: GameVersion.BlackWhite,
      initialSeed: 0x12345678,
      encounterType: 'wild',
      location: 'route-1',
      syncEnabled: false,
      maxCount: 1000
    };
    
    // 2. ç”Ÿæˆå®Ÿè¡Œ
    const results = await runPokemonGeneration(params);
    
    // 3. çµæœæ¤œè¨¼
    expect(results).toHaveLength(1000);
    
    // é­é‡åˆ†å¸ƒã®ç¢ºèª
    const speciesCount = countBySpecies(results);
    expect(speciesCount['Patrat']).toBeGreaterThan(400); // ç´„50%
    expect(speciesCount['Lillipup']).toBeGreaterThan(400); // ç´„50%
    
    // è‰²é•ã„å‡ºç¾ç‡ã®ç¢ºèª
    const shinyCount = results.filter(p => p.isShiny).length;
    expect(shinyCount).toBeGreaterThan(0);
    expect(shinyCount).toBeLessThan(results.length * 0.002); // 1/8192ã‚ˆã‚Šå°‘ã—å¤šã‚
  });
});
```

### 9.4 ãƒ†ã‚¹ãƒˆå®Ÿè¡Œæˆ¦ç•¥

#### 9.4.1 é–‹ç™ºæ™‚ãƒ†ã‚¹ãƒˆ
```bash
# WASMå˜ä½“ãƒ†ã‚¹ãƒˆ
npm run test:rust

# TypeScriptå˜ä½“ãƒ†ã‚¹ãƒˆ  
npm run test:ts

# çµ±åˆãƒ†ã‚¹ãƒˆ
npm run test:integration
```

#### 9.4.2 CI/CDãƒ†ã‚¹ãƒˆ
```bash
# å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
npm run test:all

# å‚ç…§å®Ÿè£…ã¨ã®æ¯”è¼ƒ
npm run test:reference

# ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
npm run test:performance
```

#### 9.4.3 ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿
- **æ—¢çŸ¥seedå€¤**: å‚ç…§ãƒ„ãƒ¼ãƒ«ã§æ¤œè¨¼æ¸ˆã¿ã®çµæœ
- **ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹**: è‰²é•ã„å¢ƒç•Œå€¤ã€æ€§æ ¼å¢ƒç•Œå€¤
- **å¤§é‡ãƒ‡ãƒ¼ã‚¿**: çµ±è¨ˆçš„ãªåˆ†å¸ƒç¢ºèªç”¨

## 8. å®Ÿè£…ãƒ•ã‚§ãƒ¼ã‚º

### 8.1 Phase 1: WASM Core Engineï¼ˆ3é€±é–“ï¼‰
1. **64bit LCGä¹±æ•°ã‚¨ãƒ³ã‚¸ãƒ³å®Ÿè£…**
   - æ­£ç¢ºãªç·šå½¢åˆåŒæ³•ï¼ˆ0x5D588B656C078965 + 0x269EC3ï¼‰
   - BW/BW2åˆ¥ã®é­é‡ã‚¹ãƒ­ãƒƒãƒˆè¨ˆç®—
   - æ€§æ ¼å€¤ç”Ÿæˆãƒ»è‰²é•ã„åˆ¤å®š
2. **é­é‡ãƒ‘ã‚¿ãƒ¼ãƒ³å®Ÿè£…**
   - é‡ç”Ÿãƒ»å›ºå®šã‚·ãƒ³ãƒœãƒ«ãƒ»å¾˜å¾Šãƒ»ãªã¿ã®ã‚Šãƒ»ã¤ã‚Šãƒ»å¤§é‡ç™ºç”Ÿ
   - æ­£ç¢ºãªä¹±æ•°æ¶ˆè²»é †åº
3. **RawPokemonDataæ§‹é€ ä½“**
   - WASM-TypeScripté–“ãƒ‡ãƒ¼ã‚¿ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
4. **åŸºæœ¬ãƒ†ã‚¹ãƒˆ**
   - å‚ç…§å®Ÿè£…ã¨ã®ä¸€è‡´ç¢ºèª
   - å„é­é‡ã‚¿ã‚¤ãƒ—ã®å‹•ä½œæ¤œè¨¼

### 8.2 Phase 2: TypeScript Integrationï¼ˆ2é€±é–“ï¼‰
1. **çµæœãƒ‘ãƒ¼ã‚µãƒ¼å®Ÿè£…**
   - WASMå‡ºåŠ›ã®TypeScriptå‹å¤‰æ›
   - ç¨®æ—ãƒ»ç‰¹æ€§ãƒ»æ€§åˆ¥æ±ºå®šãƒ­ã‚¸ãƒƒã‚¯
2. **ãƒ‡ãƒ¼ã‚¿ç®¡ç†**
   - ç¨®æ—ãƒ‡ãƒ¼ã‚¿ãƒ»é­é‡ãƒ†ãƒ¼ãƒ–ãƒ«ãƒ»ç‰¹æ€§ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
   - ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
3. **WASMãƒ©ãƒƒãƒ‘ãƒ¼ã‚µãƒ¼ãƒ“ã‚¹**
   - ç”Ÿæˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ¤œè¨¼ãƒ»å¤‰æ›
   - ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
4. **çµ±åˆãƒ†ã‚¹ãƒˆ**
   - WASM-TypeScripté€£æºç¢ºèª
   - ãƒ‡ãƒ¼ã‚¿å¤‰æ›ã®æ­£ç¢ºæ€§æ¤œè¨¼

### 8.3 Phase 3: UI Componentsï¼ˆ2é€±é–“ï¼‰
1. **å…¥åŠ›ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ**
   - åŸºæœ¬ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ»é­é‡è¨­å®šãƒ•ã‚©ãƒ¼ãƒ 
   - ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½
2. **çµæœè¡¨ç¤ºã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ**
   - ãƒ†ãƒ¼ãƒ–ãƒ«ãƒ»ã‚«ãƒ¼ãƒ‰è¡¨ç¤º
   - ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ãƒ»ã‚½ãƒ¼ãƒˆ
3. **åˆ¶å¾¡ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ**
   - ç”Ÿæˆé–‹å§‹ãƒ»åœæ­¢ãƒ»é€²æ—è¡¨ç¤º
   - ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæ©Ÿèƒ½
4. **çŠ¶æ…‹ç®¡ç†**
   - Zustand storeå®Ÿè£…

### 8.4 Phase 4: WebWorker & Performanceï¼ˆ1é€±é–“ï¼‰
1. **WebWorkerå®Ÿè£…**
   - WASM + WebWorkeré€£æº
   - ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å‡¦ç†
2. **ãƒãƒƒãƒå‡¦ç†æœ€é©åŒ–**
   - å¤§é‡ç”Ÿæˆæ™‚ã®ãƒ¡ãƒ¢ãƒªåŠ¹ç‡åŒ–
   - é€²æ—é€šçŸ¥ã®æœ€é©åŒ–
3. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ**
   - ç”Ÿæˆé€Ÿåº¦æ¸¬å®š
   - ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ç›£è¦–

### 8.5 Phase 5: Polish & Validationï¼ˆ1é€±é–“ï¼‰
1. **å“è³ªå‘ä¸Š**
   - ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–
   - ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£æ”¹å–„
2. **åŒ…æ‹¬ãƒ†ã‚¹ãƒˆ**
   - E2Eãƒ†ã‚¹ãƒˆå®Ÿè£…
   - æ—¢çŸ¥ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ã®æ¤œè¨¼
3. **ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ•´å‚™**
   - APIä»•æ§˜æ›¸
   - ä½¿ç”¨æ–¹æ³•ã‚¬ã‚¤ãƒ‰

### 8.6 å®Ÿè£…å„ªå…ˆé †ä½

**æœ€å„ªå…ˆï¼ˆPhase 1å¿…é ˆï¼‰**
- 64bit LCGå®Ÿè£…
- BW/BW2é­é‡ã‚¹ãƒ­ãƒƒãƒˆè¨ˆç®—
- æ€§æ ¼å€¤ãƒ»è‰²é•ã„åˆ¤å®š

**é«˜å„ªå…ˆï¼ˆPhase 2å¿…é ˆï¼‰**
- WASMçµæœãƒ‘ãƒ¼ã‚µãƒ¼
- åŸºæœ¬ãƒ‡ãƒ¼ã‚¿ç®¡ç†
- çµ±åˆãƒ†ã‚¹ãƒˆ

**ä¸­å„ªå…ˆï¼ˆPhase 3-4ï¼‰**
- UIå®Ÿè£…
- WebWorkeré€£æº

**ä½å„ªå…ˆï¼ˆPhase 5ï¼‰**
- å“è³ªå‘ä¸Š
- è©³ç´°ãƒ†ã‚¹ãƒˆ

### 8.7 ä¾å­˜é–¢ä¿‚

```
Phase 1 (WASM Core) 
    â†“
Phase 2 (TS Integration) 
    â†“ 
Phase 3 (UI Components)
    â†“
Phase 4 (Performance)
    â†“
Phase 5 (Polish)
```

**é‡è¦**: Phase 1ã®WASMå®Ÿè£…å®Œäº†ãŒå…¨ä½“ã®å‰ææ¡ä»¶ã€‚TypeScriptå´ã¯WASMçµæœã®è¡¨ç¤ºãƒ»å¤‰æ›ã®ã¿ã‚’æ‹…å½“ã€‚



---

**ä½œæˆæ—¥**: 2025å¹´8æœˆ2æ—¥  
**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 1.0  
**ä½œæˆè€…**: GitHub Copilot  
**ä¾å­˜**: pokemon-generation-feature-spec.md, pokemon-data-specification.md, pokemon-generation-ui-spec.md
